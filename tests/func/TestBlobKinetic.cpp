/**
 * This file is part of the test tools for the OpenIO client libraries
 * Copyright (C) 2016 OpenIO SAS
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.0 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library.
 */

#include <gtest/gtest.h>
#include <gflags/gflags.h>
#include <glog/logging.h>

#include <array>

#include "utils/macros.h"
#include "utils/utils.h"
#include "oio/api/blob.h"
#include "oio/blob/kinetic/coro/client/ClientInterface.h"
#include "oio/blob/kinetic/coro/client/CoroutineClientFactory.h"
#include "oio/blob/kinetic/coro/blob.h"
#include "tests/common/BlobTestSuite.h"

using oio::api::Cause;

using oio::kinetic::client::ClientFactory;
using oio::kinetic::client::CoroutineClientFactory;
using oio::kinetic::blob::UploadBuilder;
using oio::kinetic::blob::RemovalBuilder;
using oio::kinetic::blob::ListingBuilder;
using oio::kinetic::blob::DownloadBuilder;

namespace blob = ::oio::api::blob;
using blob::Upload;
using blob::Download;
using blob::Removal;

// The default address used for the target RAWX is an address typically
// generated by the oio-reset.sh tool applied on the "SINGLE" preset.
DEFINE_string(
        URL_DEVICE,
        "127.0.0.1:8123",
        "URL of the test kinetic device");

using SocketFactory =
    std::shared_ptr<oio::kinetic::client::CoroutineClientFactory>;

class KineticBlobOpsFactory : public BlobOpsFactory {
    friend class KineticBlobTestSuite;

 protected:
    std::string url_, name_;
    SocketFactory socketFactory_;

 public:
    ~KineticBlobOpsFactory() override {}

    KineticBlobOpsFactory(SocketFactory sf, std::string u) :
            url_(u), socketFactory_(sf) {}

    std::unique_ptr<oio::api::blob::Upload> Upload() override {
        UploadBuilder op(socketFactory_);
        op.Name(name_);
        op.Target(FLAGS_URL_DEVICE);
        return op.Build();
    }

    std::unique_ptr<oio::api::blob::Download> Download() override {
        DownloadBuilder op(socketFactory_);
        op.Name(name_);
        op.Target(FLAGS_URL_DEVICE);
        return op.Build();
    }

    std::unique_ptr<oio::api::blob::Removal> Removal() override {
        RemovalBuilder op(socketFactory_);
        op.Name(name_);
        op.Target(FLAGS_URL_DEVICE);
        return op.Build();
    }
};

class KineticBlobTestSuite : public BlobTestSuite {
 protected:
    std::string url_;
    SocketFactory socketFactory_;

 protected:
    ~KineticBlobTestSuite() override {}

    KineticBlobTestSuite(): ::BlobTestSuite() {
        url_.assign(FLAGS_URL_DEVICE);
    }

    void SetUp() override {
        socketFactory_.reset(new oio::kinetic::client::CoroutineClientFactory);
        auto f = new KineticBlobOpsFactory(socketFactory_, url_);
        f->name_ = generate_string_random(16, random_hex);
        this->factory_ = f;
    }

    void TearDown() override {
        delete this->factory_;
        this->factory_ = nullptr;
    }
};

DECLARE_BLOBTESTSUITE(KineticBlobTestSuite);

int main(int argc, char **argv) {
    gflags::ParseCommandLineFlags(&argc, &argv, true);
    google::InitGoogleLogging(argv[0]);
    ::testing::InitGoogleTest(&argc, argv);
    FLAGS_logtostderr = true;

    return RUN_ALL_TESTS();
}
